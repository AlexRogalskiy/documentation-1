{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { MenuNode } from '@/tools/menu/menu-node';\nimport { normaliseTitle, replaceAll } from '@/tools/utils';\nimport { defaultsDeep, flow, get, has, set, unset } from 'lodash';\nimport { MenuSegment } from './menu-segment';\nexport class MenuStructureGenerator {\n  constructor() {\n    _defineProperty(this, \"structure\", {});\n\n    _defineProperty(this, \"fileName\", void 0);\n\n    _defineProperty(this, \"segments\", void 0);\n\n    _defineProperty(this, \"segment\", void 0);\n\n    _defineProperty(this, \"keyArray\", void 0);\n\n    _defineProperty(this, \"permalinkPathArray\", void 0);\n\n    _defineProperty(this, \"seoFriendlyPathArray\", void 0);\n\n    _defineProperty(this, \"versionOfCurrentPath\", void 0);\n\n    _defineProperty(this, \"addSegmentToKey\", segment => this.keyArray.push(segment));\n\n    _defineProperty(this, \"addSegmentToPermalinkPath\", segment => this.permalinkPathArray.push(segment));\n\n    _defineProperty(this, \"addSegmentToSeoFriendlyPath\", segment => this.seoFriendlyPathArray.push(segment));\n\n    _defineProperty(this, \"setVersionOfCurrentPath\", segment => {\n      this.versionOfCurrentPath = segment;\n    });\n  }\n\n  get key() {\n    return this.keyArray.join('.');\n  }\n\n  get permalinkPath() {\n    return this.permalinkPathArray.join('/');\n  }\n\n  get seoFriendlyPath() {\n    return this.seoFriendlyPathArray.join('/');\n  }\n\n  reset() {\n    this.versionOfCurrentPath = null;\n    this.keyArray = [];\n    this.permalinkPathArray = [];\n    this.seoFriendlyPathArray = [];\n  }\n\n  static async generateMenuStructure(fileNames) {\n    // eslint-disable-next-line no-console\n    console.log('event - generating menu structure');\n    const structure = new this();\n\n    for (const fileName of fileNames) {\n      structure.addFromFile(fileName);\n    }\n\n    structure.stripVersionNumbersFromLatestVersionInSeoFriendlyPath();\n    structure.cleanup();\n    return structure.toObject();\n  }\n\n  toString() {\n    return JSON.stringify(this.structure, null, 2);\n  }\n\n  toObject() {\n    return this.structure;\n  }\n\n  addFromFile(fileName) {\n    this.reset();\n    this.fileName = fileName;\n    this.segments = this.fileName.replace(/\\.md$/, '').split('/');\n    this.addStructureFromSegments();\n    this.addMetaForFileNode();\n  }\n\n  addStructureFromSegments() {\n    for (this.segment of this.segments) {\n      const {\n        order,\n        segment\n      } = this.extractInfoFromSegment(); // Make version parts identifiable\n\n      if (MenuSegment.isVersion(segment)) {\n        this.addSegmentToKey(MenuSegment.versionContainerIdentifier);\n        this.setNodeType('identifier');\n        this.setNodePath(this.permalinkPath);\n        this.setVersionOfCurrentPath(segment);\n        this.setNodeCurrentVersion(segment);\n      } // Update pointers\n\n\n      this.addSegmentToKey(segment);\n      this.addSegmentToPermalinkPath(segment);\n      if (!MenuSegment.isVersion(segment)) this.addSegmentToSeoFriendlyPath(segment); // Add meta for every part\n\n      if (!has(this.structure, this.key)) {\n        this.setNodeType(MenuSegment.isVersion(segment) ? 'version' : 'folder');\n        this.setNodeOrder(order);\n        this.setNodePath(this.permalinkPath);\n        this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n      }\n    }\n  }\n\n  addMetaForFileNode() {\n    const {\n      order,\n      segment\n    } = this.extractInfoFromSegment();\n    this.setNodeName(normaliseTitle(segment));\n    this.setNodeType('file');\n    this.setNodeOrder(order);\n    this.setNodePath(this.permalinkPath);\n    this.setNodePermalinkPath(this.permalinkPath);\n    this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n    this.setNodeAbsolutePath(this.fileName);\n    this.setNodeVersion(this.versionOfCurrentPath);\n  }\n\n  extractInfoFromSegment() {\n    const sortOrderNumberRegex = /^\\d{2}-/;\n\n    const extractSortOrderNumber = part => {\n      var _part$match, _part$match$;\n\n      return Number(((_part$match = part.match(sortOrderNumberRegex)) === null || _part$match === void 0 ? void 0 : (_part$match$ = _part$match[0]) === null || _part$match$ === void 0 ? void 0 : _part$match$.replace(/-$/, '')) || 99);\n    };\n\n    const stripSortOrderNumber = part => {\n      return part.replace(sortOrderNumberRegex, '');\n    };\n\n    const removeForbiddenCharacters = part => {\n      return replaceAll(part, '.', '-');\n    };\n\n    const sanitiseSegment = flow(stripSortOrderNumber, removeForbiddenCharacters);\n    return {\n      order: extractSortOrderNumber(this.segment),\n      segment: sanitiseSegment(this.segment)\n    };\n  }\n\n  setNodeName(name) {\n    set(this.structure, this.key, {\n      name\n    });\n  }\n  /**\r\n   * Add meta to currently selected key.\r\n   *\r\n   * New properties overwrite existing properties recursively.\r\n   *\r\n   * Example:\r\n   *   Before:     { a: 1, b: 2 }\r\n   *   Add:        { a: 3, c: 4 }\r\n   *   Results in: { a: 3, b: 2, c: 4 }\r\n   */\n\n\n  addNodeMeta(meta) {\n    const previousMeta = get(this.structure, `${this.key}.meta`, {});\n    defaultsDeep(meta, previousMeta);\n    set(this.structure, `${this.key}.meta`, meta);\n  }\n  /**\r\n   * Type of part, to indicate its structure\r\n   */\n\n\n  setNodeType(type) {\n    this.addNodeMeta({\n      type\n    });\n  }\n  /**\r\n   * Order in which to appear in the menu\r\n   */\n\n\n  setNodeOrder(order) {\n    this.addNodeMeta({\n      order\n    });\n  }\n  /**\r\n   * For routing\r\n   */\n\n\n  setNodePath(path) {\n    this.addNodeMeta({\n      path\n    });\n  }\n  /**\r\n   * For linking back to the file in the repo\r\n   */\n\n\n  setNodeAbsolutePath(absolutePath) {\n    this.addNodeMeta({\n      absolutePath\n    });\n  }\n  /**\r\n   * For linking to a section for a specific version using an anchor\r\n   */\n\n\n  setNodePermalinkPath(permalinkPath) {\n    this.addNodeMeta({\n      permalinkPath\n    });\n  }\n  /**\r\n   * For overwriting `path` in case for latest version path\r\n   *\r\n   * Example: to overwrite `path` github/v2/doc with `seoFriendlyPath` github/doc if v2 is current.\r\n   */\n\n\n  setNodeSeoFriendlyPath(seoFriendlyPath) {\n    this.addNodeMeta({\n      seoFriendlyPath\n    });\n  }\n  /**\r\n   * Version of parent or self\r\n   */\n\n\n  setNodeVersion(version) {\n    this.addNodeMeta({\n      version\n    });\n  }\n  /**\r\n   * To overwrite currentVersion in meta every time a newer version is found\r\n   */\n\n\n  setNodeCurrentVersion(currentVersion) {\n    if (!MenuSegment.isVersion(currentVersion)) {\n      throw new Error('expected version to match a version part');\n    }\n\n    this.addNodeMeta({\n      currentVersion\n    });\n  }\n\n  stripVersionNumbersFromLatestVersionInSeoFriendlyPath() {\n    const updateSeoPathsRecursively = (collection, replacePath = null, withPath = null) => {\n      for (const [segment, node] of Object.entries(collection)) {\n        if (MenuSegment.isMeta(segment)) continue; // Example: Recursively replace /github/v[latest]/something with /github/something.\n\n        if (replacePath && withPath && has(node, 'meta.path')) {\n          set(collection, `${segment}.meta.path`, node.meta.path.replace(replacePath, withPath));\n        }\n\n        if (!MenuNode.hasChildren(node)) {\n          continue;\n        }\n\n        if (MenuSegment.isVersionContainer(segment)) {\n          const {\n            currentVersion\n          } = node.meta;\n          const {\n            seoFriendlyPath\n          } = node[currentVersion].meta;\n          const replace = get(collection, `${segment}.${currentVersion}.meta.path`);\n          set(collection, `${segment}.${currentVersion}.meta.path`, seoFriendlyPath);\n          updateSeoPathsRecursively(node, replace, seoFriendlyPath);\n          continue;\n        }\n\n        updateSeoPathsRecursively(node, replacePath, withPath);\n      }\n    };\n\n    updateSeoPathsRecursively(this.structure);\n  }\n\n  cleanup() {\n    const cleanupRecursively = collection => {\n      for (const [segment, node] of Object.entries(collection)) {\n        if (MenuSegment.isMeta(segment)) continue;\n        unset(collection, `${segment}.meta.seoFriendlyPath`);\n\n        if (MenuNode.hasChildren(node)) {\n          cleanupRecursively(node);\n        }\n      }\n    };\n\n    cleanupRecursively(this.structure);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}