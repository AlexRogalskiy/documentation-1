{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { MenuNode } from '@/tools/menu/menu-node';\nimport { normaliseTitle, replaceAll } from '@/tools/utils';\nimport { defaultsDeep, flow, get, has, set, unset } from 'lodash';\nimport { MenuSegment } from './menu-segment';\nexport var MenuStructureGenerator = /*#__PURE__*/function () {\n  function MenuStructureGenerator() {\n    var _this = this;\n\n    _classCallCheck(this, MenuStructureGenerator);\n\n    _defineProperty(this, \"structure\", {});\n\n    _defineProperty(this, \"fileName\", void 0);\n\n    _defineProperty(this, \"segments\", void 0);\n\n    _defineProperty(this, \"segment\", void 0);\n\n    _defineProperty(this, \"keyArray\", void 0);\n\n    _defineProperty(this, \"permalinkPathArray\", void 0);\n\n    _defineProperty(this, \"seoFriendlyPathArray\", void 0);\n\n    _defineProperty(this, \"versionOfCurrentPath\", void 0);\n\n    _defineProperty(this, \"addSegmentToKey\", function (segment) {\n      return _this.keyArray.push(segment);\n    });\n\n    _defineProperty(this, \"addSegmentToPermalinkPath\", function (segment) {\n      return _this.permalinkPathArray.push(segment);\n    });\n\n    _defineProperty(this, \"addSegmentToSeoFriendlyPath\", function (segment) {\n      return _this.seoFriendlyPathArray.push(segment);\n    });\n\n    _defineProperty(this, \"setVersionOfCurrentPath\", function (segment) {\n      _this.versionOfCurrentPath = segment;\n    });\n  }\n\n  _createClass(MenuStructureGenerator, [{\n    key: \"key\",\n    get: function get() {\n      return this.keyArray.join('.');\n    }\n  }, {\n    key: \"permalinkPath\",\n    get: function get() {\n      return this.permalinkPathArray.join('/');\n    }\n  }, {\n    key: \"seoFriendlyPath\",\n    get: function get() {\n      return this.seoFriendlyPathArray.join('/');\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.versionOfCurrentPath = null;\n      this.keyArray = [];\n      this.permalinkPathArray = [];\n      this.seoFriendlyPathArray = [];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return JSON.stringify(this.structure, null, 2);\n    }\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return this.structure;\n    }\n  }, {\n    key: \"addFromFile\",\n    value: function addFromFile(fileName) {\n      this.reset();\n      this.fileName = fileName;\n      this.segments = this.fileName.replace(/\\.md$/, '').split('/');\n      this.addStructureFromSegments();\n      this.addMetaForFileNode();\n    }\n  }, {\n    key: \"addStructureFromSegments\",\n    value: function addStructureFromSegments() {\n      var _iterator = _createForOfIteratorHelper(this.segments),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          this.segment = _step.value;\n\n          var _this$extractInfoFrom = this.extractInfoFromSegment(),\n              order = _this$extractInfoFrom.order,\n              segment = _this$extractInfoFrom.segment; // Make version parts identifiable\n\n\n          if (MenuSegment.isVersion(segment)) {\n            this.addSegmentToKey(MenuSegment.versionContainerIdentifier);\n            this.setNodeType('identifier');\n            this.setNodePath(this.permalinkPath);\n            this.setVersionOfCurrentPath(segment);\n            this.setNodeCurrentVersion(segment);\n          } // Update pointers\n\n\n          this.addSegmentToKey(segment);\n          this.addSegmentToPermalinkPath(segment);\n          if (!MenuSegment.isVersion(segment)) this.addSegmentToSeoFriendlyPath(segment); // Add meta for every part\n\n          if (!has(this.structure, this.key)) {\n            this.setNodeType(MenuSegment.isVersion(segment) ? 'version' : 'folder');\n            this.setNodeOrder(order);\n            this.setNodePath(this.permalinkPath);\n            this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"addMetaForFileNode\",\n    value: function addMetaForFileNode() {\n      var _this$extractInfoFrom2 = this.extractInfoFromSegment(),\n          order = _this$extractInfoFrom2.order,\n          segment = _this$extractInfoFrom2.segment;\n\n      this.setNodeName(normaliseTitle(segment));\n      this.setNodeType('file');\n      this.setNodeOrder(order);\n      this.setNodePath(this.permalinkPath);\n      this.setNodePermalinkPath(this.permalinkPath);\n      this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n      this.setNodeAbsolutePath(this.fileName);\n      this.setNodeVersion(this.versionOfCurrentPath);\n    }\n  }, {\n    key: \"extractInfoFromSegment\",\n    value: function extractInfoFromSegment() {\n      var sortOrderNumberRegex = /^\\d{2}-/;\n\n      var extractSortOrderNumber = function extractSortOrderNumber(part) {\n        var _part$match, _part$match$;\n\n        return Number(((_part$match = part.match(sortOrderNumberRegex)) === null || _part$match === void 0 ? void 0 : (_part$match$ = _part$match[0]) === null || _part$match$ === void 0 ? void 0 : _part$match$.replace(/-$/, '')) || 99);\n      };\n\n      var stripSortOrderNumber = function stripSortOrderNumber(part) {\n        return part.replace(sortOrderNumberRegex, '');\n      };\n\n      var removeForbiddenCharacters = function removeForbiddenCharacters(part) {\n        return replaceAll(part, '.', '-');\n      };\n\n      var sanitiseSegment = flow(stripSortOrderNumber, removeForbiddenCharacters);\n      return {\n        order: extractSortOrderNumber(this.segment),\n        segment: sanitiseSegment(this.segment)\n      };\n    }\n  }, {\n    key: \"setNodeName\",\n    value: function setNodeName(name) {\n      set(this.structure, this.key, {\n        name: name\n      });\n    }\n    /**\r\n     * Add meta to currently selected key.\r\n     *\r\n     * New properties overwrite existing properties recursively.\r\n     *\r\n     * Example:\r\n     *   Before:     { a: 1, b: 2 }\r\n     *   Add:        { a: 3, c: 4 }\r\n     *   Results in: { a: 3, b: 2, c: 4 }\r\n     */\n\n  }, {\n    key: \"addNodeMeta\",\n    value: function addNodeMeta(meta) {\n      var previousMeta = get(this.structure, \"\".concat(this.key, \".meta\"), {});\n      defaultsDeep(meta, previousMeta);\n      set(this.structure, \"\".concat(this.key, \".meta\"), meta);\n    }\n    /**\r\n     * Type of part, to indicate its structure\r\n     */\n\n  }, {\n    key: \"setNodeType\",\n    value: function setNodeType(type) {\n      this.addNodeMeta({\n        type: type\n      });\n    }\n    /**\r\n     * Order in which to appear in the menu\r\n     */\n\n  }, {\n    key: \"setNodeOrder\",\n    value: function setNodeOrder(order) {\n      this.addNodeMeta({\n        order: order\n      });\n    }\n    /**\r\n     * For routing\r\n     */\n\n  }, {\n    key: \"setNodePath\",\n    value: function setNodePath(path) {\n      this.addNodeMeta({\n        path: path\n      });\n    }\n    /**\r\n     * For linking back to the file in the repo\r\n     */\n\n  }, {\n    key: \"setNodeAbsolutePath\",\n    value: function setNodeAbsolutePath(absolutePath) {\n      this.addNodeMeta({\n        absolutePath: absolutePath\n      });\n    }\n    /**\r\n     * For linking to a section for a specific version using an anchor\r\n     */\n\n  }, {\n    key: \"setNodePermalinkPath\",\n    value: function setNodePermalinkPath(permalinkPath) {\n      this.addNodeMeta({\n        permalinkPath: permalinkPath\n      });\n    }\n    /**\r\n     * For overwriting `path` in case for latest version path\r\n     *\r\n     * Example: to overwrite `path` github/v2/doc with `seoFriendlyPath` github/doc if v2 is current.\r\n     */\n\n  }, {\n    key: \"setNodeSeoFriendlyPath\",\n    value: function setNodeSeoFriendlyPath(seoFriendlyPath) {\n      this.addNodeMeta({\n        seoFriendlyPath: seoFriendlyPath\n      });\n    }\n    /**\r\n     * Version of parent or self\r\n     */\n\n  }, {\n    key: \"setNodeVersion\",\n    value: function setNodeVersion(version) {\n      this.addNodeMeta({\n        version: version\n      });\n    }\n    /**\r\n     * To overwrite currentVersion in meta every time a newer version is found\r\n     */\n\n  }, {\n    key: \"setNodeCurrentVersion\",\n    value: function setNodeCurrentVersion(currentVersion) {\n      if (!MenuSegment.isVersion(currentVersion)) {\n        throw new Error('expected version to match a version part');\n      }\n\n      this.addNodeMeta({\n        currentVersion: currentVersion\n      });\n    }\n  }, {\n    key: \"stripVersionNumbersFromLatestVersionInSeoFriendlyPath\",\n    value: function stripVersionNumbersFromLatestVersionInSeoFriendlyPath() {\n      var updateSeoPathsRecursively = function updateSeoPathsRecursively(collection) {\n        var replacePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var withPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        for (var _i = 0, _Object$entries = Object.entries(collection); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              segment = _Object$entries$_i[0],\n              node = _Object$entries$_i[1];\n\n          if (MenuSegment.isMeta(segment)) continue; // Example: Recursively replace /github/v[latest]/something with /github/something.\n\n          if (replacePath && withPath && has(node, 'meta.path')) {\n            set(collection, \"\".concat(segment, \".meta.path\"), node.meta.path.replace(replacePath, withPath));\n          }\n\n          if (!MenuNode.hasChildren(node)) {\n            continue;\n          }\n\n          if (MenuSegment.isVersionContainer(segment)) {\n            var currentVersion = node.meta.currentVersion;\n            var seoFriendlyPath = node[currentVersion].meta.seoFriendlyPath;\n            var replace = get(collection, \"\".concat(segment, \".\").concat(currentVersion, \".meta.path\"));\n            set(collection, \"\".concat(segment, \".\").concat(currentVersion, \".meta.path\"), seoFriendlyPath);\n            updateSeoPathsRecursively(node, replace, seoFriendlyPath);\n            continue;\n          }\n\n          updateSeoPathsRecursively(node, replacePath, withPath);\n        }\n      };\n\n      updateSeoPathsRecursively(this.structure);\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var cleanupRecursively = function cleanupRecursively(collection) {\n        for (var _i2 = 0, _Object$entries2 = Object.entries(collection); _i2 < _Object$entries2.length; _i2++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n              segment = _Object$entries2$_i[0],\n              node = _Object$entries2$_i[1];\n\n          if (MenuSegment.isMeta(segment)) continue;\n          unset(collection, \"\".concat(segment, \".meta.seoFriendlyPath\"));\n\n          if (MenuNode.hasChildren(node)) {\n            cleanupRecursively(node);\n          }\n        }\n      };\n\n      cleanupRecursively(this.structure);\n    }\n  }], [{\n    key: \"generateMenuStructure\",\n    value: function () {\n      var _generateMenuStructure = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileNames) {\n        var structure, _iterator2, _step2, fileName;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // eslint-disable-next-line no-console\n                console.log('event - generating menu structure');\n                structure = new this();\n                _iterator2 = _createForOfIteratorHelper(fileNames);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    fileName = _step2.value;\n                    structure.addFromFile(fileName);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                structure.stripVersionNumbersFromLatestVersionInSeoFriendlyPath();\n                structure.cleanup();\n                return _context.abrupt(\"return\", structure.toObject());\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function generateMenuStructure(_x) {\n        return _generateMenuStructure.apply(this, arguments);\n      }\n\n      return generateMenuStructure;\n    }()\n  }]);\n\n  return MenuStructureGenerator;\n}();","map":null,"metadata":{},"sourceType":"module"}