{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { MenuNode } from '@/tools/menu/menu-node';\nimport { normaliseTitle, replaceAll } from '@/tools/utils';\nimport { defaultsDeep, flow, get, has, set, unset } from 'lodash';\nimport { MenuSegment } from './menu-segment';\nexport class MenuStructureGenerator {\n  constructor() {\n    _defineProperty(this, \"structure\", {});\n\n    _defineProperty(this, \"fileName\", void 0);\n\n    _defineProperty(this, \"segments\", void 0);\n\n    _defineProperty(this, \"segment\", void 0);\n\n    _defineProperty(this, \"keyArray\", void 0);\n\n    _defineProperty(this, \"permalinkPathArray\", void 0);\n\n    _defineProperty(this, \"seoFriendlyPathArray\", void 0);\n\n    _defineProperty(this, \"versionOfCurrentPath\", void 0);\n\n    _defineProperty(this, \"addSegmentToKey\", segment => this.keyArray.push(segment));\n\n    _defineProperty(this, \"addSegmentToPermalinkPath\", segment => this.permalinkPathArray.push(segment));\n\n    _defineProperty(this, \"addSegmentToSeoFriendlyPath\", segment => this.seoFriendlyPathArray.push(segment));\n\n    _defineProperty(this, \"setVersionOfCurrentPath\", segment => {\n      this.versionOfCurrentPath = segment;\n    });\n  }\n\n  get key() {\n    return this.keyArray.join('.');\n  }\n\n  get permalinkPath() {\n    return this.permalinkPathArray.join('/');\n  }\n\n  get seoFriendlyPath() {\n    return this.seoFriendlyPathArray.join('/');\n  }\n\n  reset() {\n    this.versionOfCurrentPath = null;\n    this.keyArray = [];\n    this.permalinkPathArray = [];\n    this.seoFriendlyPathArray = [];\n  }\n\n  static async generateMenuStructure(fileNames) {\n    // eslint-disable-next-line no-console\n    console.log('event - generating menu structure');\n    const structure = new this();\n\n    for (const fileName of fileNames) {\n      structure.addFromFile(fileName);\n    }\n\n    structure.stripVersionNumbersFromLatestVersionInSeoFriendlyPath();\n    structure.cleanup();\n    return structure.toObject();\n  }\n\n  toString() {\n    return JSON.stringify(this.structure, null, 2);\n  }\n\n  toObject() {\n    return this.structure;\n  }\n\n  addFromFile(fileName) {\n    this.reset();\n    this.fileName = fileName;\n    this.segments = this.fileName.replace(/\\.md$/, '').split('/');\n    this.addStructureFromSegments();\n    this.addMetaForFileNode();\n  }\n\n  addStructureFromSegments() {\n    for (this.segment of this.segments) {\n      const {\n        order,\n        segment\n      } = this.extractInfoFromSegment(); // Make version parts identifiable\n\n      if (MenuSegment.isVersion(segment)) {\n        this.addSegmentToKey(MenuSegment.versionContainerIdentifier);\n        this.setNodeType('identifier');\n        this.setNodePath(this.permalinkPath);\n        this.setVersionOfCurrentPath(segment);\n        this.setNodeCurrentVersion(segment);\n      } // Update pointers\n\n\n      this.addSegmentToKey(segment);\n      this.addSegmentToPermalinkPath(segment);\n      if (!MenuSegment.isVersion(segment)) this.addSegmentToSeoFriendlyPath(segment); // Add meta for every part\n\n      if (!has(this.structure, this.key)) {\n        this.setNodeType(MenuSegment.isVersion(segment) ? 'version' : 'folder');\n        this.setNodeOrder(order);\n        this.setNodePath(this.permalinkPath);\n        this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n      }\n    }\n  }\n\n  addMetaForFileNode() {\n    const {\n      order,\n      segment\n    } = this.extractInfoFromSegment();\n    this.setNodeName(normaliseTitle(segment));\n    this.setNodeType('file');\n    this.setNodeOrder(order);\n    this.setNodePath(this.permalinkPath);\n    this.setNodePermalinkPath(this.permalinkPath);\n    this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n    this.setNodeAbsolutePath(this.fileName);\n    this.setNodeVersion(this.versionOfCurrentPath);\n  }\n\n  extractInfoFromSegment() {\n    const sortOrderNumberRegex = /^\\d{2}-/;\n\n    const extractSortOrderNumber = part => {\n      var _part$match, _part$match$;\n\n      return Number(((_part$match = part.match(sortOrderNumberRegex)) === null || _part$match === void 0 ? void 0 : (_part$match$ = _part$match[0]) === null || _part$match$ === void 0 ? void 0 : _part$match$.replace(/-$/, '')) || 99);\n    };\n\n    const stripSortOrderNumber = part => {\n      return part.replace(sortOrderNumberRegex, '');\n    };\n\n    const removeForbiddenCharacters = part => {\n      return replaceAll(part, '.', '-');\n    };\n\n    const sanitiseSegment = flow(stripSortOrderNumber, removeForbiddenCharacters);\n    return {\n      order: extractSortOrderNumber(this.segment),\n      segment: sanitiseSegment(this.segment)\n    };\n  }\n\n  setNodeName(name) {\n    set(this.structure, this.key, {\n      name\n    });\n  }\n  /**\r\n   * Add meta to currently selected key.\r\n   *\r\n   * New properties overwrite existing properties recursively.\r\n   *\r\n   * Example:\r\n   *   Before:     { a: 1, b: 2 }\r\n   *   Add:        { a: 3, c: 4 }\r\n   *   Results in: { a: 3, b: 2, c: 4 }\r\n   */\n\n\n  addNodeMeta(meta) {\n    const previousMeta = get(this.structure, `${this.key}.meta`, {});\n    defaultsDeep(meta, previousMeta);\n    set(this.structure, `${this.key}.meta`, meta);\n  }\n  /**\r\n   * Type of part, to indicate its structure\r\n   */\n\n\n  setNodeType(type) {\n    this.addNodeMeta({\n      type\n    });\n  }\n  /**\r\n   * Order in which to appear in the menu\r\n   */\n\n\n  setNodeOrder(order) {\n    this.addNodeMeta({\n      order\n    });\n  }\n  /**\r\n   * For routing\r\n   */\n\n\n  setNodePath(path) {\n    this.addNodeMeta({\n      path\n    });\n  }\n  /**\r\n   * For linking back to the file in the repo\r\n   */\n\n\n  setNodeAbsolutePath(absolutePath) {\n    this.addNodeMeta({\n      absolutePath\n    });\n  }\n  /**\r\n   * For linking to a section for a specific version using an anchor\r\n   */\n\n\n  setNodePermalinkPath(permalinkPath) {\n    this.addNodeMeta({\n      permalinkPath\n    });\n  }\n  /**\r\n   * For overwriting `path` in case for latest version path\r\n   *\r\n   * Example: to overwrite `path` github/v2/doc with `seoFriendlyPath` github/doc if v2 is current.\r\n   */\n\n\n  setNodeSeoFriendlyPath(seoFriendlyPath) {\n    this.addNodeMeta({\n      seoFriendlyPath\n    });\n  }\n  /**\r\n   * Version of parent or self\r\n   */\n\n\n  setNodeVersion(version) {\n    this.addNodeMeta({\n      version\n    });\n  }\n  /**\r\n   * To overwrite currentVersion in meta every time a newer version is found\r\n   */\n\n\n  setNodeCurrentVersion(currentVersion) {\n    if (!MenuSegment.isVersion(currentVersion)) {\n      throw new Error('expected version to match a version part');\n    }\n\n    this.addNodeMeta({\n      currentVersion\n    });\n  }\n\n  stripVersionNumbersFromLatestVersionInSeoFriendlyPath() {\n    const updateSeoPathsRecursively = (collection, replacePath = null, withPath = null) => {\n      for (const [segment, node] of Object.entries(collection)) {\n        if (MenuSegment.isMeta(segment)) continue; // Example: Recursively replace /github/v[latest]/something with /github/something.\n\n        if (replacePath && withPath && has(node, 'meta.path')) {\n          set(collection, `${segment}.meta.path`, node.meta.path.replace(replacePath, withPath));\n        }\n\n        if (!MenuNode.hasChildren(node)) {\n          continue;\n        }\n\n        if (MenuSegment.isVersionContainer(segment)) {\n          const {\n            currentVersion\n          } = node.meta;\n          const {\n            seoFriendlyPath\n          } = node[currentVersion].meta;\n          const replace = get(collection, `${segment}.${currentVersion}.meta.path`);\n          set(collection, `${segment}.${currentVersion}.meta.path`, seoFriendlyPath);\n          updateSeoPathsRecursively(node, replace, seoFriendlyPath);\n          continue;\n        }\n\n        updateSeoPathsRecursively(node, replacePath, withPath);\n      }\n    };\n\n    updateSeoPathsRecursively(this.structure);\n  }\n\n  cleanup() {\n    const cleanupRecursively = collection => {\n      for (const [segment, node] of Object.entries(collection)) {\n        if (MenuSegment.isMeta(segment)) continue;\n        unset(collection, `${segment}.meta.seoFriendlyPath`);\n\n        if (MenuNode.hasChildren(node)) {\n          cleanupRecursively(node);\n        }\n      }\n    };\n\n    cleanupRecursively(this.structure);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Mark/Documents/documentation/tools/menu/menu-structure-generator.ts"],"names":["MenuNode","normaliseTitle","replaceAll","defaultsDeep","flow","get","has","set","unset","MenuSegment","MenuStructureGenerator","segment","keyArray","push","permalinkPathArray","seoFriendlyPathArray","versionOfCurrentPath","key","join","permalinkPath","seoFriendlyPath","reset","generateMenuStructure","fileNames","console","log","structure","fileName","addFromFile","stripVersionNumbersFromLatestVersionInSeoFriendlyPath","cleanup","toObject","toString","JSON","stringify","segments","replace","split","addStructureFromSegments","addMetaForFileNode","order","extractInfoFromSegment","isVersion","addSegmentToKey","versionContainerIdentifier","setNodeType","setNodePath","setVersionOfCurrentPath","setNodeCurrentVersion","addSegmentToPermalinkPath","addSegmentToSeoFriendlyPath","setNodeOrder","setNodeSeoFriendlyPath","setNodeName","setNodePermalinkPath","setNodeAbsolutePath","setNodeVersion","sortOrderNumberRegex","extractSortOrderNumber","part","Number","match","stripSortOrderNumber","removeForbiddenCharacters","sanitiseSegment","name","addNodeMeta","meta","previousMeta","type","path","absolutePath","version","currentVersion","Error","updateSeoPathsRecursively","collection","replacePath","withPath","node","Object","entries","isMeta","hasChildren","isVersionContainer","cleanupRecursively"],"mappings":";;AAAA,SAASA,QAAT,QAAuC,wBAAvC;AACA,SAASC,cAAT,EAAyBC,UAAzB,QAA2C,eAA3C;AACA,SAASC,YAAT,EAAuBC,IAAvB,EAA6BC,GAA7B,EAAkCC,GAAlC,EAAuCC,GAAvC,EAA4CC,KAA5C,QAAyD,QAAzD;AACA,SAASC,WAAT,QAA4B,gBAA5B;AAEA,OAAO,MAAMC,sBAAN,CAA6B;AAAA;AAAA,uCACJ,EADI;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA,6CAoCPC,OAAD,IAAa,KAAKC,QAAL,CAAcC,IAAd,CAAmBF,OAAnB,CApCL;;AAAA,uDAsCGA,OAAD,IAAa,KAAKG,kBAAL,CAAwBD,IAAxB,CAA6BF,OAA7B,CAtCf;;AAAA,yDAwCKA,OAAD,IAAa,KAAKI,oBAAL,CAA0BF,IAA1B,CAA+BF,OAA/B,CAxCjB;;AAAA,qDA0CCA,OAAD,IAAa;AAC7C,WAAKK,oBAAL,GAA4BL,OAA5B;AACD,KA5CiC;AAAA;;AAiBnB,MAAHM,GAAG,GAAG;AAChB,WAAO,KAAKL,QAAL,CAAcM,IAAd,CAAmB,GAAnB,CAAP;AACD;;AAEwB,MAAbC,aAAa,GAAG;AAC1B,WAAO,KAAKL,kBAAL,CAAwBI,IAAxB,CAA6B,GAA7B,CAAP;AACD;;AAE0B,MAAfE,eAAe,GAAG;AAC5B,WAAO,KAAKL,oBAAL,CAA0BG,IAA1B,CAA+B,GAA/B,CAAP;AACD;;AAEOG,EAAAA,KAAK,GAAG;AACd,SAAKL,oBAAL,GAA4B,IAA5B;AACA,SAAKJ,QAAL,GAAgB,EAAhB;AACA,SAAKE,kBAAL,GAA0B,EAA1B;AACA,SAAKC,oBAAL,GAA4B,EAA5B;AACD;;AAYiC,eAArBO,qBAAqB,CAACC,SAAD,EAAsB;AACtD;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,mCAAZ;AAEA,UAAMC,SAAS,GAAG,IAAI,IAAJ,EAAlB;;AACA,SAAK,MAAMC,QAAX,IAAuBJ,SAAvB,EAAkC;AAChCG,MAAAA,SAAS,CAACE,WAAV,CAAsBD,QAAtB;AACD;;AAEDD,IAAAA,SAAS,CAACG,qDAAV;AACAH,IAAAA,SAAS,CAACI,OAAV;AAEA,WAAOJ,SAAS,CAACK,QAAV,EAAP;AACD;;AAEMC,EAAAA,QAAQ,GAAG;AAChB,WAAOC,IAAI,CAACC,SAAL,CAAe,KAAKR,SAApB,EAA+B,IAA/B,EAAqC,CAArC,CAAP;AACD;;AAEMK,EAAAA,QAAQ,GAAG;AAChB,WAAO,KAAKL,SAAZ;AACD;;AAEME,EAAAA,WAAW,CAACD,QAAD,EAAmB;AACnC,SAAKN,KAAL;AAEA,SAAKM,QAAL,GAAgBA,QAAhB;AACA,SAAKQ,QAAL,GAAgB,KAAKR,QAAL,CAAcS,OAAd,CAAsB,OAAtB,EAA+B,EAA/B,EAAmCC,KAAnC,CAAyC,GAAzC,CAAhB;AAEA,SAAKC,wBAAL;AACA,SAAKC,kBAAL;AACD;;AAEOD,EAAAA,wBAAwB,GAAG;AACjC,SAAK,KAAK3B,OAAV,IAAqB,KAAKwB,QAA1B,EAAoC;AAClC,YAAM;AAAEK,QAAAA,KAAF;AAAS7B,QAAAA;AAAT,UAAqB,KAAK8B,sBAAL,EAA3B,CADkC,CAGlC;;AACA,UAAIhC,WAAW,CAACiC,SAAZ,CAAsB/B,OAAtB,CAAJ,EAAoC;AAClC,aAAKgC,eAAL,CAAqBlC,WAAW,CAACmC,0BAAjC;AACA,aAAKC,WAAL,CAAiB,YAAjB;AACA,aAAKC,WAAL,CAAiB,KAAK3B,aAAtB;AACA,aAAK4B,uBAAL,CAA6BpC,OAA7B;AACA,aAAKqC,qBAAL,CAA2BrC,OAA3B;AACD,OAViC,CAYlC;;;AACA,WAAKgC,eAAL,CAAqBhC,OAArB;AACA,WAAKsC,yBAAL,CAA+BtC,OAA/B;AACA,UAAI,CAACF,WAAW,CAACiC,SAAZ,CAAsB/B,OAAtB,CAAL,EAAqC,KAAKuC,2BAAL,CAAiCvC,OAAjC,EAfH,CAiBlC;;AACA,UAAI,CAACL,GAAG,CAAC,KAAKoB,SAAN,EAAiB,KAAKT,GAAtB,CAAR,EAAoC;AAClC,aAAK4B,WAAL,CAAiBpC,WAAW,CAACiC,SAAZ,CAAsB/B,OAAtB,IAAiC,SAAjC,GAA6C,QAA9D;AACA,aAAKwC,YAAL,CAAkBX,KAAlB;AACA,aAAKM,WAAL,CAAiB,KAAK3B,aAAtB;AACA,aAAKiC,sBAAL,CAA4B,KAAKhC,eAAjC;AACD;AACF;AACF;;AAEOmB,EAAAA,kBAAkB,GAAG;AAC3B,UAAM;AAAEC,MAAAA,KAAF;AAAS7B,MAAAA;AAAT,QAAqB,KAAK8B,sBAAL,EAA3B;AAEA,SAAKY,WAAL,CAAiBpD,cAAc,CAACU,OAAD,CAA/B;AACA,SAAKkC,WAAL,CAAiB,MAAjB;AACA,SAAKM,YAAL,CAAkBX,KAAlB;AACA,SAAKM,WAAL,CAAiB,KAAK3B,aAAtB;AACA,SAAKmC,oBAAL,CAA0B,KAAKnC,aAA/B;AACA,SAAKiC,sBAAL,CAA4B,KAAKhC,eAAjC;AACA,SAAKmC,mBAAL,CAAyB,KAAK5B,QAA9B;AACA,SAAK6B,cAAL,CAAoB,KAAKxC,oBAAzB;AACD;;AAEOyB,EAAAA,sBAAsB,GAAG;AAC/B,UAAMgB,oBAAoB,GAAG,SAA7B;;AAEA,UAAMC,sBAAsB,GAAIC,IAAD,IAA0B;AAAA;;AACvD,aAAOC,MAAM,CAAC,gBAAAD,IAAI,CAACE,KAAL,CAAWJ,oBAAX,6EAAmC,CAAnC,+DAAuCrB,OAAvC,CAA+C,IAA/C,EAAqD,EAArD,MAA4D,EAA7D,CAAb;AACD,KAFD;;AAIA,UAAM0B,oBAAoB,GAAIH,IAAD,IAA0B;AACrD,aAAOA,IAAI,CAACvB,OAAL,CAAaqB,oBAAb,EAAmC,EAAnC,CAAP;AACD,KAFD;;AAIA,UAAMM,yBAAyB,GAAIJ,IAAD,IAA0B;AAC1D,aAAOzD,UAAU,CAACyD,IAAD,EAAO,GAAP,EAAY,GAAZ,CAAjB;AACD,KAFD;;AAIA,UAAMK,eAAe,GAAG5D,IAAI,CAAC0D,oBAAD,EAAuBC,yBAAvB,CAA5B;AAEA,WAAO;AACLvB,MAAAA,KAAK,EAAEkB,sBAAsB,CAAC,KAAK/C,OAAN,CADxB;AAELA,MAAAA,OAAO,EAAEqD,eAAe,CAAC,KAAKrD,OAAN;AAFnB,KAAP;AAID;;AAEO0C,EAAAA,WAAW,CAACY,IAAD,EAAO;AACxB1D,IAAAA,GAAG,CAAC,KAAKmB,SAAN,EAAiB,KAAKT,GAAtB,EAA2B;AAAEgD,MAAAA;AAAF,KAA3B,CAAH;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACxB,UAAMC,YAAY,GAAG/D,GAAG,CAAC,KAAKqB,SAAN,EAAkB,GAAE,KAAKT,GAAI,OAA7B,EAAqC,EAArC,CAAxB;AACAd,IAAAA,YAAY,CAACgE,IAAD,EAAOC,YAAP,CAAZ;AACA7D,IAAAA,GAAG,CAAC,KAAKmB,SAAN,EAAkB,GAAE,KAAKT,GAAI,OAA7B,EAAqCkD,IAArC,CAAH;AACD;AAED;AACF;AACA;;;AACUtB,EAAAA,WAAW,CAACwB,IAAD,EAAqB;AACtC,SAAKH,WAAL,CAAiB;AAAEG,MAAAA;AAAF,KAAjB;AACD;AAED;AACF;AACA;;;AACUlB,EAAAA,YAAY,CAACX,KAAD,EAAgB;AAClC,SAAK0B,WAAL,CAAiB;AAAE1B,MAAAA;AAAF,KAAjB;AACD;AAED;AACF;AACA;;;AACUM,EAAAA,WAAW,CAACwB,IAAD,EAAe;AAChC,SAAKJ,WAAL,CAAiB;AAAEI,MAAAA;AAAF,KAAjB;AACD;AAED;AACF;AACA;;;AACUf,EAAAA,mBAAmB,CAACgB,YAAD,EAAuB;AAChD,SAAKL,WAAL,CAAiB;AAAEK,MAAAA;AAAF,KAAjB;AACD;AAED;AACF;AACA;;;AACUjB,EAAAA,oBAAoB,CAACnC,aAAD,EAAwB;AAClD,SAAK+C,WAAL,CAAiB;AAAE/C,MAAAA;AAAF,KAAjB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACUiC,EAAAA,sBAAsB,CAAChC,eAAD,EAA0B;AACtD,SAAK8C,WAAL,CAAiB;AAAE9C,MAAAA;AAAF,KAAjB;AACD;AAED;AACF;AACA;;;AACUoC,EAAAA,cAAc,CAACgB,OAAD,EAAkB;AACtC,SAAKN,WAAL,CAAiB;AAAEM,MAAAA;AAAF,KAAjB;AACD;AAED;AACF;AACA;;;AACUxB,EAAAA,qBAAqB,CAACyB,cAAD,EAAyB;AACpD,QAAI,CAAChE,WAAW,CAACiC,SAAZ,CAAsB+B,cAAtB,CAAL,EAA4C;AAC1C,YAAM,IAAIC,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,SAAKR,WAAL,CAAiB;AAAEO,MAAAA;AAAF,KAAjB;AACD;;AAEO5C,EAAAA,qDAAqD,GAAG;AAC9D,UAAM8C,yBAAyB,GAAG,CAChCC,UADgC,EAEhCC,WAAW,GAAG,IAFkB,EAGhCC,QAAQ,GAAG,IAHqB,KAI7B;AACH,WAAK,MAAM,CAACnE,OAAD,EAAUoE,IAAV,CAAX,IAA8BC,MAAM,CAACC,OAAP,CAAeL,UAAf,CAA9B,EAA0D;AACxD,YAAInE,WAAW,CAACyE,MAAZ,CAAmBvE,OAAnB,CAAJ,EAAiC,SADuB,CAGxD;;AACA,YAAIkE,WAAW,IAAIC,QAAf,IAA2BxE,GAAG,CAACyE,IAAD,EAAO,WAAP,CAAlC,EAAuD;AACrDxE,UAAAA,GAAG,CAACqE,UAAD,EAAc,GAAEjE,OAAQ,YAAxB,EAAqCoE,IAAI,CAACZ,IAAL,CAAUG,IAAV,CAAelC,OAAf,CAAuByC,WAAvB,EAAoCC,QAApC,CAArC,CAAH;AACD;;AAED,YAAI,CAAC9E,QAAQ,CAACmF,WAAT,CAAqBJ,IAArB,CAAL,EAAiC;AAC/B;AACD;;AAED,YAAItE,WAAW,CAAC2E,kBAAZ,CAA+BzE,OAA/B,CAAJ,EAA6C;AAC3C,gBAAM;AAAE8D,YAAAA;AAAF,cAAqBM,IAAI,CAACZ,IAAhC;AACA,gBAAM;AAAE/C,YAAAA;AAAF,cAAsB2D,IAAI,CAACN,cAAD,CAAJ,CAAqBN,IAAjD;AACA,gBAAM/B,OAAO,GAAG/B,GAAG,CAACuE,UAAD,EAAc,GAAEjE,OAAQ,IAAG8D,cAAe,YAA1C,CAAnB;AACAlE,UAAAA,GAAG,CAACqE,UAAD,EAAc,GAAEjE,OAAQ,IAAG8D,cAAe,YAA1C,EAAuDrD,eAAvD,CAAH;AACAuD,UAAAA,yBAAyB,CAACI,IAAD,EAAO3C,OAAP,EAAgBhB,eAAhB,CAAzB;AACA;AACD;;AAEDuD,QAAAA,yBAAyB,CAACI,IAAD,EAAOF,WAAP,EAAoBC,QAApB,CAAzB;AACD;AACF,KA5BD;;AA8BAH,IAAAA,yBAAyB,CAAC,KAAKjD,SAAN,CAAzB;AACD;;AAEOI,EAAAA,OAAO,GAAG;AAChB,UAAMuD,kBAAkB,GAAIT,UAAD,IAA0B;AACnD,WAAK,MAAM,CAACjE,OAAD,EAAUoE,IAAV,CAAX,IAA8BC,MAAM,CAACC,OAAP,CAAeL,UAAf,CAA9B,EAA0D;AACxD,YAAInE,WAAW,CAACyE,MAAZ,CAAmBvE,OAAnB,CAAJ,EAAiC;AAEjCH,QAAAA,KAAK,CAACoE,UAAD,EAAc,GAAEjE,OAAQ,uBAAxB,CAAL;;AAEA,YAAIX,QAAQ,CAACmF,WAAT,CAAqBJ,IAArB,CAAJ,EAAgC;AAC9BM,UAAAA,kBAAkB,CAACN,IAAD,CAAlB;AACD;AACF;AACF,KAVD;;AAWAM,IAAAA,kBAAkB,CAAC,KAAK3D,SAAN,CAAlB;AACD;;AAhRiC","sourcesContent":["import { MenuNode, MenuNodeType } from '@/tools/menu/menu-node';\r\nimport { normaliseTitle, replaceAll } from '@/tools/utils';\r\nimport { defaultsDeep, flow, get, has, set, unset } from 'lodash';\r\nimport { MenuSegment } from './menu-segment';\r\n\r\nexport class MenuStructureGenerator {\r\n  private structure: MenuNode = {};\r\n\r\n  private fileName: string;\r\n\r\n  private segments: string[];\r\n\r\n  private segment: string;\r\n\r\n  private keyArray: string[];\r\n\r\n  private permalinkPathArray: string[];\r\n\r\n  private seoFriendlyPathArray: string[];\r\n\r\n  private versionOfCurrentPath: string;\r\n\r\n  private get key() {\r\n    return this.keyArray.join('.');\r\n  }\r\n\r\n  private get permalinkPath() {\r\n    return this.permalinkPathArray.join('/');\r\n  }\r\n\r\n  private get seoFriendlyPath() {\r\n    return this.seoFriendlyPathArray.join('/');\r\n  }\r\n\r\n  private reset() {\r\n    this.versionOfCurrentPath = null;\r\n    this.keyArray = [];\r\n    this.permalinkPathArray = [];\r\n    this.seoFriendlyPathArray = [];\r\n  }\r\n\r\n  private addSegmentToKey = (segment) => this.keyArray.push(segment);\r\n\r\n  private addSegmentToPermalinkPath = (segment) => this.permalinkPathArray.push(segment);\r\n\r\n  private addSegmentToSeoFriendlyPath = (segment) => this.seoFriendlyPathArray.push(segment);\r\n\r\n  private setVersionOfCurrentPath = (segment) => {\r\n    this.versionOfCurrentPath = segment;\r\n  };\r\n\r\n  static async generateMenuStructure(fileNames: string[]) {\r\n    // eslint-disable-next-line no-console\r\n    console.log('event - generating menu structure');\r\n\r\n    const structure = new this();\r\n    for (const fileName of fileNames) {\r\n      structure.addFromFile(fileName);\r\n    }\r\n\r\n    structure.stripVersionNumbersFromLatestVersionInSeoFriendlyPath();\r\n    structure.cleanup();\r\n\r\n    return structure.toObject();\r\n  }\r\n\r\n  public toString() {\r\n    return JSON.stringify(this.structure, null, 2);\r\n  }\r\n\r\n  public toObject() {\r\n    return this.structure;\r\n  }\r\n\r\n  public addFromFile(fileName: string) {\r\n    this.reset();\r\n\r\n    this.fileName = fileName;\r\n    this.segments = this.fileName.replace(/\\.md$/, '').split('/');\r\n\r\n    this.addStructureFromSegments();\r\n    this.addMetaForFileNode();\r\n  }\r\n\r\n  private addStructureFromSegments() {\r\n    for (this.segment of this.segments) {\r\n      const { order, segment } = this.extractInfoFromSegment();\r\n\r\n      // Make version parts identifiable\r\n      if (MenuSegment.isVersion(segment)) {\r\n        this.addSegmentToKey(MenuSegment.versionContainerIdentifier);\r\n        this.setNodeType('identifier');\r\n        this.setNodePath(this.permalinkPath);\r\n        this.setVersionOfCurrentPath(segment);\r\n        this.setNodeCurrentVersion(segment);\r\n      }\r\n\r\n      // Update pointers\r\n      this.addSegmentToKey(segment);\r\n      this.addSegmentToPermalinkPath(segment);\r\n      if (!MenuSegment.isVersion(segment)) this.addSegmentToSeoFriendlyPath(segment);\r\n\r\n      // Add meta for every part\r\n      if (!has(this.structure, this.key)) {\r\n        this.setNodeType(MenuSegment.isVersion(segment) ? 'version' : 'folder');\r\n        this.setNodeOrder(order);\r\n        this.setNodePath(this.permalinkPath);\r\n        this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  private addMetaForFileNode() {\r\n    const { order, segment } = this.extractInfoFromSegment();\r\n\r\n    this.setNodeName(normaliseTitle(segment));\r\n    this.setNodeType('file');\r\n    this.setNodeOrder(order);\r\n    this.setNodePath(this.permalinkPath);\r\n    this.setNodePermalinkPath(this.permalinkPath);\r\n    this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\r\n    this.setNodeAbsolutePath(this.fileName);\r\n    this.setNodeVersion(this.versionOfCurrentPath);\r\n  }\r\n\r\n  private extractInfoFromSegment() {\r\n    const sortOrderNumberRegex = /^\\d{2}-/;\r\n\r\n    const extractSortOrderNumber = (part: string): number => {\r\n      return Number(part.match(sortOrderNumberRegex)?.[0]?.replace(/-$/, '') || 99);\r\n    };\r\n\r\n    const stripSortOrderNumber = (part: string): string => {\r\n      return part.replace(sortOrderNumberRegex, '');\r\n    };\r\n\r\n    const removeForbiddenCharacters = (part: string): string => {\r\n      return replaceAll(part, '.', '-');\r\n    };\r\n\r\n    const sanitiseSegment = flow(stripSortOrderNumber, removeForbiddenCharacters);\r\n\r\n    return {\r\n      order: extractSortOrderNumber(this.segment),\r\n      segment: sanitiseSegment(this.segment),\r\n    };\r\n  }\r\n\r\n  private setNodeName(name) {\r\n    set(this.structure, this.key, { name });\r\n  }\r\n\r\n  /**\r\n   * Add meta to currently selected key.\r\n   *\r\n   * New properties overwrite existing properties recursively.\r\n   *\r\n   * Example:\r\n   *   Before:     { a: 1, b: 2 }\r\n   *   Add:        { a: 3, c: 4 }\r\n   *   Results in: { a: 3, b: 2, c: 4 }\r\n   */\r\n  private addNodeMeta(meta) {\r\n    const previousMeta = get(this.structure, `${this.key}.meta`, {});\r\n    defaultsDeep(meta, previousMeta);\r\n    set(this.structure, `${this.key}.meta`, meta);\r\n  }\r\n\r\n  /**\r\n   * Type of part, to indicate its structure\r\n   */\r\n  private setNodeType(type: MenuNodeType) {\r\n    this.addNodeMeta({ type });\r\n  }\r\n\r\n  /**\r\n   * Order in which to appear in the menu\r\n   */\r\n  private setNodeOrder(order: number) {\r\n    this.addNodeMeta({ order });\r\n  }\r\n\r\n  /**\r\n   * For routing\r\n   */\r\n  private setNodePath(path: string) {\r\n    this.addNodeMeta({ path });\r\n  }\r\n\r\n  /**\r\n   * For linking back to the file in the repo\r\n   */\r\n  private setNodeAbsolutePath(absolutePath: string) {\r\n    this.addNodeMeta({ absolutePath });\r\n  }\r\n\r\n  /**\r\n   * For linking to a section for a specific version using an anchor\r\n   */\r\n  private setNodePermalinkPath(permalinkPath: string) {\r\n    this.addNodeMeta({ permalinkPath });\r\n  }\r\n\r\n  /**\r\n   * For overwriting `path` in case for latest version path\r\n   *\r\n   * Example: to overwrite `path` github/v2/doc with `seoFriendlyPath` github/doc if v2 is current.\r\n   */\r\n  private setNodeSeoFriendlyPath(seoFriendlyPath: string) {\r\n    this.addNodeMeta({ seoFriendlyPath });\r\n  }\r\n\r\n  /**\r\n   * Version of parent or self\r\n   */\r\n  private setNodeVersion(version: string) {\r\n    this.addNodeMeta({ version });\r\n  }\r\n\r\n  /**\r\n   * To overwrite currentVersion in meta every time a newer version is found\r\n   */\r\n  private setNodeCurrentVersion(currentVersion: string) {\r\n    if (!MenuSegment.isVersion(currentVersion)) {\r\n      throw new Error('expected version to match a version part');\r\n    }\r\n\r\n    this.addNodeMeta({ currentVersion });\r\n  }\r\n\r\n  private stripVersionNumbersFromLatestVersionInSeoFriendlyPath() {\r\n    const updateSeoPathsRecursively = (\r\n      collection: MenuNode,\r\n      replacePath = null,\r\n      withPath = null,\r\n    ) => {\r\n      for (const [segment, node] of Object.entries(collection)) {\r\n        if (MenuSegment.isMeta(segment)) continue;\r\n\r\n        // Example: Recursively replace /github/v[latest]/something with /github/something.\r\n        if (replacePath && withPath && has(node, 'meta.path')) {\r\n          set(collection, `${segment}.meta.path`, node.meta.path.replace(replacePath, withPath));\r\n        }\r\n\r\n        if (!MenuNode.hasChildren(node)) {\r\n          continue;\r\n        }\r\n\r\n        if (MenuSegment.isVersionContainer(segment)) {\r\n          const { currentVersion } = node.meta;\r\n          const { seoFriendlyPath } = node[currentVersion].meta;\r\n          const replace = get(collection, `${segment}.${currentVersion}.meta.path`);\r\n          set(collection, `${segment}.${currentVersion}.meta.path`, seoFriendlyPath);\r\n          updateSeoPathsRecursively(node, replace, seoFriendlyPath);\r\n          continue;\r\n        }\r\n\r\n        updateSeoPathsRecursively(node, replacePath, withPath);\r\n      }\r\n    };\r\n\r\n    updateSeoPathsRecursively(this.structure);\r\n  }\r\n\r\n  private cleanup() {\r\n    const cleanupRecursively = (collection: MenuNode) => {\r\n      for (const [segment, node] of Object.entries(collection)) {\r\n        if (MenuSegment.isMeta(segment)) continue;\r\n\r\n        unset(collection, `${segment}.meta.seoFriendlyPath`);\r\n\r\n        if (MenuNode.hasChildren(node)) {\r\n          cleanupRecursively(node);\r\n        }\r\n      }\r\n    };\r\n    cleanupRecursively(this.structure);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}