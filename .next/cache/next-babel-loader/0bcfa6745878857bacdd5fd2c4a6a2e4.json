{"ast":null,"code":"import UnityVersion from '@/components/docs/versions/unity-version';\nimport Heading from '@/components/markdown/components/heading';\nimport { Collapse } from 'antd';\nimport React, { useEffect } from 'react';\nimport { useFirestore, useFirestoreCollectionData } from 'reactfire';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nconst UnityVersions = ({\n  selectedRepoVersion,\n  setIsLoading\n}) => {\n  if (!selectedRepoVersion) return null;\n  const ciJobs = useFirestore().collection('ciJobs').orderBy('editorVersionInfo.major', 'desc').orderBy('editorVersionInfo.minor', 'desc').orderBy('editorVersionInfo.patch', 'desc').where('repoVersionInfo.version', '==', selectedRepoVersion);\n  const {\n    status,\n    data\n  } = useFirestoreCollectionData(ciJobs);\n  const isLoading = status === 'loading';\n  useEffect(() => {\n    setIsLoading(isLoading);\n  });\n\n  const loading = /*#__PURE__*/_jsx(\"p\", {\n    children: \"Fetching versions...\"\n  });\n\n  const failures = isLoading ? [] : data.filter(version => version.status === 'failed');\n\n  if (data) {\n    // Sorting the data based on the version numbers to maintain the version order\n    data.sort((a, b) => {\n      const infoA = a.editorVersionInfo;\n      const infoB = b.editorVersionInfo; // Using major , minor and patch to compare the two numbers\n\n      const {\n        major: majorA,\n        minor: minorA,\n        patch: patchA\n      } = infoA;\n      const {\n        major: majorB,\n        minor: minorB,\n        patch: patchB\n      } = infoB; // First checking for major version.\n\n      if (majorA > majorB) return -1;\n      if (majorA < majorB) return 1; // If major version is equal check for minor version.\n\n      if (minorA > minorB) return -1;\n      if (minorA < minorB) return 1; // If major and minor both are equal check the patch version.\n      // For patch assuming \"f\" is present and splitting based on that.(Can use regex to split also).\n      // Calculating a patchNumber which is the priority offset based sum of the numbers in\n      // the array formed after split. The offset is used to correctly get the priority.\n\n      let patchANumber = 0;\n\n      for (const [index, currentValue] of patchA.split('f').entries()) {\n        patchANumber += 10 ** (9 - 3 * index) * Number.parseInt(currentValue, 10);\n      }\n\n      let patchBNumber = 0;\n\n      for (const [index, currentValue] of patchB.split('f').entries()) {\n        patchBNumber += 10 ** (9 - 3 * index) * Number.parseInt(currentValue, 10);\n      }\n\n      return patchBNumber - patchANumber;\n    });\n  }\n\n  return /*#__PURE__*/_jsxs(\"main\", {\n    style: {\n      paddingTop: 24\n    },\n    children: [failures.length > 0 && /*#__PURE__*/_jsxs(_Fragment, {\n      children: [/*#__PURE__*/_jsx(Heading, {\n        level: 3,\n        children: \"Current failures\"\n      }), /*#__PURE__*/_jsx(Collapse, {\n        accordion: true,\n        style: {\n          marginBottom: 24\n        },\n        children: failures.map(version => /*#__PURE__*/_jsx(UnityVersion, {\n          data: version\n        }, version.NO_ID_FIELD))\n      })]\n    }), /*#__PURE__*/_jsx(Heading, {\n      level: 3,\n      children: \"All versions\"\n    }), /*#__PURE__*/_jsx(Collapse, {\n      accordion: true,\n      children: isLoading ? loading : data.map(version => /*#__PURE__*/_jsx(UnityVersion, {\n        data: version\n      }, version.NO_ID_FIELD))\n    })]\n  });\n};\n\nexport default UnityVersions;","map":null,"metadata":{},"sourceType":"module"}