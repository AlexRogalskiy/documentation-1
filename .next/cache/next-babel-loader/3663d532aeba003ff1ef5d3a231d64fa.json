{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { MenuNode } from '@/tools/menu/menu-node';\nimport { normaliseTitle, replaceAll } from '@/tools/utils';\nimport { defaultsDeep, flow, get, has, set, unset } from 'lodash';\nimport { MenuSegment } from './menu-segment';\nexport var MenuStructureGenerator = /*#__PURE__*/function () {\n  function MenuStructureGenerator() {\n    var _this = this;\n\n    _classCallCheck(this, MenuStructureGenerator);\n\n    _defineProperty(this, \"structure\", {});\n\n    _defineProperty(this, \"fileName\", void 0);\n\n    _defineProperty(this, \"segments\", void 0);\n\n    _defineProperty(this, \"segment\", void 0);\n\n    _defineProperty(this, \"keyArray\", void 0);\n\n    _defineProperty(this, \"permalinkPathArray\", void 0);\n\n    _defineProperty(this, \"seoFriendlyPathArray\", void 0);\n\n    _defineProperty(this, \"versionOfCurrentPath\", void 0);\n\n    _defineProperty(this, \"addSegmentToKey\", function (segment) {\n      return _this.keyArray.push(segment);\n    });\n\n    _defineProperty(this, \"addSegmentToPermalinkPath\", function (segment) {\n      return _this.permalinkPathArray.push(segment);\n    });\n\n    _defineProperty(this, \"addSegmentToSeoFriendlyPath\", function (segment) {\n      return _this.seoFriendlyPathArray.push(segment);\n    });\n\n    _defineProperty(this, \"setVersionOfCurrentPath\", function (segment) {\n      _this.versionOfCurrentPath = segment;\n    });\n  }\n\n  _createClass(MenuStructureGenerator, [{\n    key: \"key\",\n    get: function get() {\n      return this.keyArray.join('.');\n    }\n  }, {\n    key: \"permalinkPath\",\n    get: function get() {\n      return this.permalinkPathArray.join('/');\n    }\n  }, {\n    key: \"seoFriendlyPath\",\n    get: function get() {\n      return this.seoFriendlyPathArray.join('/');\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.versionOfCurrentPath = null;\n      this.keyArray = [];\n      this.permalinkPathArray = [];\n      this.seoFriendlyPathArray = [];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return JSON.stringify(this.structure, null, 2);\n    }\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return this.structure;\n    }\n  }, {\n    key: \"addFromFile\",\n    value: function addFromFile(fileName) {\n      this.reset();\n      this.fileName = fileName;\n      this.segments = this.fileName.replace(/\\.md$/, '').split('/');\n      this.addStructureFromSegments();\n      this.addMetaForFileNode();\n    }\n  }, {\n    key: \"addStructureFromSegments\",\n    value: function addStructureFromSegments() {\n      var _iterator = _createForOfIteratorHelper(this.segments),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          this.segment = _step.value;\n\n          var _this$extractInfoFrom = this.extractInfoFromSegment(),\n              order = _this$extractInfoFrom.order,\n              segment = _this$extractInfoFrom.segment; // Make version parts identifiable\n\n\n          if (MenuSegment.isVersion(segment)) {\n            this.addSegmentToKey(MenuSegment.versionContainerIdentifier);\n            this.setNodeType('identifier');\n            this.setNodePath(this.permalinkPath);\n            this.setVersionOfCurrentPath(segment);\n            this.setNodeCurrentVersion(segment);\n          } // Update pointers\n\n\n          this.addSegmentToKey(segment);\n          this.addSegmentToPermalinkPath(segment);\n          if (!MenuSegment.isVersion(segment)) this.addSegmentToSeoFriendlyPath(segment); // Add meta for every part\n\n          if (!has(this.structure, this.key)) {\n            this.setNodeType(MenuSegment.isVersion(segment) ? 'version' : 'folder');\n            this.setNodeOrder(order);\n            this.setNodePath(this.permalinkPath);\n            this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"addMetaForFileNode\",\n    value: function addMetaForFileNode() {\n      var _this$extractInfoFrom2 = this.extractInfoFromSegment(),\n          order = _this$extractInfoFrom2.order,\n          segment = _this$extractInfoFrom2.segment;\n\n      this.setNodeName(normaliseTitle(segment));\n      this.setNodeType('file');\n      this.setNodeOrder(order);\n      this.setNodePath(this.permalinkPath);\n      this.setNodePermalinkPath(this.permalinkPath);\n      this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\n      this.setNodeAbsolutePath(this.fileName);\n      this.setNodeVersion(this.versionOfCurrentPath);\n    }\n  }, {\n    key: \"extractInfoFromSegment\",\n    value: function extractInfoFromSegment() {\n      var sortOrderNumberRegex = /^\\d{2}-/;\n\n      var extractSortOrderNumber = function extractSortOrderNumber(part) {\n        var _part$match, _part$match$;\n\n        return Number(((_part$match = part.match(sortOrderNumberRegex)) === null || _part$match === void 0 ? void 0 : (_part$match$ = _part$match[0]) === null || _part$match$ === void 0 ? void 0 : _part$match$.replace(/-$/, '')) || 99);\n      };\n\n      var stripSortOrderNumber = function stripSortOrderNumber(part) {\n        return part.replace(sortOrderNumberRegex, '');\n      };\n\n      var removeForbiddenCharacters = function removeForbiddenCharacters(part) {\n        return replaceAll(part, '.', '-');\n      };\n\n      var sanitiseSegment = flow(stripSortOrderNumber, removeForbiddenCharacters);\n      return {\n        order: extractSortOrderNumber(this.segment),\n        segment: sanitiseSegment(this.segment)\n      };\n    }\n  }, {\n    key: \"setNodeName\",\n    value: function setNodeName(name) {\n      set(this.structure, this.key, {\n        name: name\n      });\n    }\n    /**\r\n     * Add meta to currently selected key.\r\n     *\r\n     * New properties overwrite existing properties recursively.\r\n     *\r\n     * Example:\r\n     *   Before:     { a: 1, b: 2 }\r\n     *   Add:        { a: 3, c: 4 }\r\n     *   Results in: { a: 3, b: 2, c: 4 }\r\n     */\n\n  }, {\n    key: \"addNodeMeta\",\n    value: function addNodeMeta(meta) {\n      var previousMeta = get(this.structure, \"\".concat(this.key, \".meta\"), {});\n      defaultsDeep(meta, previousMeta);\n      set(this.structure, \"\".concat(this.key, \".meta\"), meta);\n    }\n    /**\r\n     * Type of part, to indicate its structure\r\n     */\n\n  }, {\n    key: \"setNodeType\",\n    value: function setNodeType(type) {\n      this.addNodeMeta({\n        type: type\n      });\n    }\n    /**\r\n     * Order in which to appear in the menu\r\n     */\n\n  }, {\n    key: \"setNodeOrder\",\n    value: function setNodeOrder(order) {\n      this.addNodeMeta({\n        order: order\n      });\n    }\n    /**\r\n     * For routing\r\n     */\n\n  }, {\n    key: \"setNodePath\",\n    value: function setNodePath(path) {\n      this.addNodeMeta({\n        path: path\n      });\n    }\n    /**\r\n     * For linking back to the file in the repo\r\n     */\n\n  }, {\n    key: \"setNodeAbsolutePath\",\n    value: function setNodeAbsolutePath(absolutePath) {\n      this.addNodeMeta({\n        absolutePath: absolutePath\n      });\n    }\n    /**\r\n     * For linking to a section for a specific version using an anchor\r\n     */\n\n  }, {\n    key: \"setNodePermalinkPath\",\n    value: function setNodePermalinkPath(permalinkPath) {\n      this.addNodeMeta({\n        permalinkPath: permalinkPath\n      });\n    }\n    /**\r\n     * For overwriting `path` in case for latest version path\r\n     *\r\n     * Example: to overwrite `path` github/v2/doc with `seoFriendlyPath` github/doc if v2 is current.\r\n     */\n\n  }, {\n    key: \"setNodeSeoFriendlyPath\",\n    value: function setNodeSeoFriendlyPath(seoFriendlyPath) {\n      this.addNodeMeta({\n        seoFriendlyPath: seoFriendlyPath\n      });\n    }\n    /**\r\n     * Version of parent or self\r\n     */\n\n  }, {\n    key: \"setNodeVersion\",\n    value: function setNodeVersion(version) {\n      this.addNodeMeta({\n        version: version\n      });\n    }\n    /**\r\n     * To overwrite currentVersion in meta every time a newer version is found\r\n     */\n\n  }, {\n    key: \"setNodeCurrentVersion\",\n    value: function setNodeCurrentVersion(currentVersion) {\n      if (!MenuSegment.isVersion(currentVersion)) {\n        throw new Error('expected version to match a version part');\n      }\n\n      this.addNodeMeta({\n        currentVersion: currentVersion\n      });\n    }\n  }, {\n    key: \"stripVersionNumbersFromLatestVersionInSeoFriendlyPath\",\n    value: function stripVersionNumbersFromLatestVersionInSeoFriendlyPath() {\n      var updateSeoPathsRecursively = function updateSeoPathsRecursively(collection) {\n        var replacePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var withPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        for (var _i = 0, _Object$entries = Object.entries(collection); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              segment = _Object$entries$_i[0],\n              node = _Object$entries$_i[1];\n\n          if (MenuSegment.isMeta(segment)) continue; // Example: Recursively replace /github/v[latest]/something with /github/something.\n\n          if (replacePath && withPath && has(node, 'meta.path')) {\n            set(collection, \"\".concat(segment, \".meta.path\"), node.meta.path.replace(replacePath, withPath));\n          }\n\n          if (!MenuNode.hasChildren(node)) {\n            continue;\n          }\n\n          if (MenuSegment.isVersionContainer(segment)) {\n            var currentVersion = node.meta.currentVersion;\n            var seoFriendlyPath = node[currentVersion].meta.seoFriendlyPath;\n            var replace = get(collection, \"\".concat(segment, \".\").concat(currentVersion, \".meta.path\"));\n            set(collection, \"\".concat(segment, \".\").concat(currentVersion, \".meta.path\"), seoFriendlyPath);\n            updateSeoPathsRecursively(node, replace, seoFriendlyPath);\n            continue;\n          }\n\n          updateSeoPathsRecursively(node, replacePath, withPath);\n        }\n      };\n\n      updateSeoPathsRecursively(this.structure);\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var cleanupRecursively = function cleanupRecursively(collection) {\n        for (var _i2 = 0, _Object$entries2 = Object.entries(collection); _i2 < _Object$entries2.length; _i2++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n              segment = _Object$entries2$_i[0],\n              node = _Object$entries2$_i[1];\n\n          if (MenuSegment.isMeta(segment)) continue;\n          unset(collection, \"\".concat(segment, \".meta.seoFriendlyPath\"));\n\n          if (MenuNode.hasChildren(node)) {\n            cleanupRecursively(node);\n          }\n        }\n      };\n\n      cleanupRecursively(this.structure);\n    }\n  }], [{\n    key: \"generateMenuStructure\",\n    value: function () {\n      var _generateMenuStructure = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileNames) {\n        var structure, _iterator2, _step2, fileName;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // eslint-disable-next-line no-console\n                console.log('event - generating menu structure');\n                structure = new this();\n                _iterator2 = _createForOfIteratorHelper(fileNames);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    fileName = _step2.value;\n                    structure.addFromFile(fileName);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                structure.stripVersionNumbersFromLatestVersionInSeoFriendlyPath();\n                structure.cleanup();\n                return _context.abrupt(\"return\", structure.toObject());\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function generateMenuStructure(_x) {\n        return _generateMenuStructure.apply(this, arguments);\n      }\n\n      return generateMenuStructure;\n    }()\n  }]);\n\n  return MenuStructureGenerator;\n}();","map":{"version":3,"sources":["C:/Users/Mark/Documents/documentation/tools/menu/menu-structure-generator.ts"],"names":["MenuNode","normaliseTitle","replaceAll","defaultsDeep","flow","get","has","set","unset","MenuSegment","MenuStructureGenerator","segment","keyArray","push","permalinkPathArray","seoFriendlyPathArray","versionOfCurrentPath","join","JSON","stringify","structure","fileName","reset","segments","replace","split","addStructureFromSegments","addMetaForFileNode","extractInfoFromSegment","order","isVersion","addSegmentToKey","versionContainerIdentifier","setNodeType","setNodePath","permalinkPath","setVersionOfCurrentPath","setNodeCurrentVersion","addSegmentToPermalinkPath","addSegmentToSeoFriendlyPath","key","setNodeOrder","setNodeSeoFriendlyPath","seoFriendlyPath","setNodeName","setNodePermalinkPath","setNodeAbsolutePath","setNodeVersion","sortOrderNumberRegex","extractSortOrderNumber","part","Number","match","stripSortOrderNumber","removeForbiddenCharacters","sanitiseSegment","name","meta","previousMeta","type","addNodeMeta","path","absolutePath","version","currentVersion","Error","updateSeoPathsRecursively","collection","replacePath","withPath","Object","entries","node","isMeta","hasChildren","isVersionContainer","cleanupRecursively","fileNames","console","log","addFromFile","stripVersionNumbersFromLatestVersionInSeoFriendlyPath","cleanup","toObject"],"mappings":"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","sourcesContent":["import { MenuNode, MenuNodeType } from '@/tools/menu/menu-node';\r\nimport { normaliseTitle, replaceAll } from '@/tools/utils';\r\nimport { defaultsDeep, flow, get, has, set, unset } from 'lodash';\r\nimport { MenuSegment } from './menu-segment';\r\n\r\nexport class MenuStructureGenerator {\r\n  private structure: MenuNode = {};\r\n\r\n  private fileName: string;\r\n\r\n  private segments: string[];\r\n\r\n  private segment: string;\r\n\r\n  private keyArray: string[];\r\n\r\n  private permalinkPathArray: string[];\r\n\r\n  private seoFriendlyPathArray: string[];\r\n\r\n  private versionOfCurrentPath: string;\r\n\r\n  private get key() {\r\n    return this.keyArray.join('.');\r\n  }\r\n\r\n  private get permalinkPath() {\r\n    return this.permalinkPathArray.join('/');\r\n  }\r\n\r\n  private get seoFriendlyPath() {\r\n    return this.seoFriendlyPathArray.join('/');\r\n  }\r\n\r\n  private reset() {\r\n    this.versionOfCurrentPath = null;\r\n    this.keyArray = [];\r\n    this.permalinkPathArray = [];\r\n    this.seoFriendlyPathArray = [];\r\n  }\r\n\r\n  private addSegmentToKey = (segment) => this.keyArray.push(segment);\r\n\r\n  private addSegmentToPermalinkPath = (segment) => this.permalinkPathArray.push(segment);\r\n\r\n  private addSegmentToSeoFriendlyPath = (segment) => this.seoFriendlyPathArray.push(segment);\r\n\r\n  private setVersionOfCurrentPath = (segment) => {\r\n    this.versionOfCurrentPath = segment;\r\n  };\r\n\r\n  static async generateMenuStructure(fileNames: string[]) {\r\n    // eslint-disable-next-line no-console\r\n    console.log('event - generating menu structure');\r\n\r\n    const structure = new this();\r\n    for (const fileName of fileNames) {\r\n      structure.addFromFile(fileName);\r\n    }\r\n\r\n    structure.stripVersionNumbersFromLatestVersionInSeoFriendlyPath();\r\n    structure.cleanup();\r\n\r\n    return structure.toObject();\r\n  }\r\n\r\n  public toString() {\r\n    return JSON.stringify(this.structure, null, 2);\r\n  }\r\n\r\n  public toObject() {\r\n    return this.structure;\r\n  }\r\n\r\n  public addFromFile(fileName: string) {\r\n    this.reset();\r\n\r\n    this.fileName = fileName;\r\n    this.segments = this.fileName.replace(/\\.md$/, '').split('/');\r\n\r\n    this.addStructureFromSegments();\r\n    this.addMetaForFileNode();\r\n  }\r\n\r\n  private addStructureFromSegments() {\r\n    for (this.segment of this.segments) {\r\n      const { order, segment } = this.extractInfoFromSegment();\r\n\r\n      // Make version parts identifiable\r\n      if (MenuSegment.isVersion(segment)) {\r\n        this.addSegmentToKey(MenuSegment.versionContainerIdentifier);\r\n        this.setNodeType('identifier');\r\n        this.setNodePath(this.permalinkPath);\r\n        this.setVersionOfCurrentPath(segment);\r\n        this.setNodeCurrentVersion(segment);\r\n      }\r\n\r\n      // Update pointers\r\n      this.addSegmentToKey(segment);\r\n      this.addSegmentToPermalinkPath(segment);\r\n      if (!MenuSegment.isVersion(segment)) this.addSegmentToSeoFriendlyPath(segment);\r\n\r\n      // Add meta for every part\r\n      if (!has(this.structure, this.key)) {\r\n        this.setNodeType(MenuSegment.isVersion(segment) ? 'version' : 'folder');\r\n        this.setNodeOrder(order);\r\n        this.setNodePath(this.permalinkPath);\r\n        this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  private addMetaForFileNode() {\r\n    const { order, segment } = this.extractInfoFromSegment();\r\n\r\n    this.setNodeName(normaliseTitle(segment));\r\n    this.setNodeType('file');\r\n    this.setNodeOrder(order);\r\n    this.setNodePath(this.permalinkPath);\r\n    this.setNodePermalinkPath(this.permalinkPath);\r\n    this.setNodeSeoFriendlyPath(this.seoFriendlyPath);\r\n    this.setNodeAbsolutePath(this.fileName);\r\n    this.setNodeVersion(this.versionOfCurrentPath);\r\n  }\r\n\r\n  private extractInfoFromSegment() {\r\n    const sortOrderNumberRegex = /^\\d{2}-/;\r\n\r\n    const extractSortOrderNumber = (part: string): number => {\r\n      return Number(part.match(sortOrderNumberRegex)?.[0]?.replace(/-$/, '') || 99);\r\n    };\r\n\r\n    const stripSortOrderNumber = (part: string): string => {\r\n      return part.replace(sortOrderNumberRegex, '');\r\n    };\r\n\r\n    const removeForbiddenCharacters = (part: string): string => {\r\n      return replaceAll(part, '.', '-');\r\n    };\r\n\r\n    const sanitiseSegment = flow(stripSortOrderNumber, removeForbiddenCharacters);\r\n\r\n    return {\r\n      order: extractSortOrderNumber(this.segment),\r\n      segment: sanitiseSegment(this.segment),\r\n    };\r\n  }\r\n\r\n  private setNodeName(name) {\r\n    set(this.structure, this.key, { name });\r\n  }\r\n\r\n  /**\r\n   * Add meta to currently selected key.\r\n   *\r\n   * New properties overwrite existing properties recursively.\r\n   *\r\n   * Example:\r\n   *   Before:     { a: 1, b: 2 }\r\n   *   Add:        { a: 3, c: 4 }\r\n   *   Results in: { a: 3, b: 2, c: 4 }\r\n   */\r\n  private addNodeMeta(meta) {\r\n    const previousMeta = get(this.structure, `${this.key}.meta`, {});\r\n    defaultsDeep(meta, previousMeta);\r\n    set(this.structure, `${this.key}.meta`, meta);\r\n  }\r\n\r\n  /**\r\n   * Type of part, to indicate its structure\r\n   */\r\n  private setNodeType(type: MenuNodeType) {\r\n    this.addNodeMeta({ type });\r\n  }\r\n\r\n  /**\r\n   * Order in which to appear in the menu\r\n   */\r\n  private setNodeOrder(order: number) {\r\n    this.addNodeMeta({ order });\r\n  }\r\n\r\n  /**\r\n   * For routing\r\n   */\r\n  private setNodePath(path: string) {\r\n    this.addNodeMeta({ path });\r\n  }\r\n\r\n  /**\r\n   * For linking back to the file in the repo\r\n   */\r\n  private setNodeAbsolutePath(absolutePath: string) {\r\n    this.addNodeMeta({ absolutePath });\r\n  }\r\n\r\n  /**\r\n   * For linking to a section for a specific version using an anchor\r\n   */\r\n  private setNodePermalinkPath(permalinkPath: string) {\r\n    this.addNodeMeta({ permalinkPath });\r\n  }\r\n\r\n  /**\r\n   * For overwriting `path` in case for latest version path\r\n   *\r\n   * Example: to overwrite `path` github/v2/doc with `seoFriendlyPath` github/doc if v2 is current.\r\n   */\r\n  private setNodeSeoFriendlyPath(seoFriendlyPath: string) {\r\n    this.addNodeMeta({ seoFriendlyPath });\r\n  }\r\n\r\n  /**\r\n   * Version of parent or self\r\n   */\r\n  private setNodeVersion(version: string) {\r\n    this.addNodeMeta({ version });\r\n  }\r\n\r\n  /**\r\n   * To overwrite currentVersion in meta every time a newer version is found\r\n   */\r\n  private setNodeCurrentVersion(currentVersion: string) {\r\n    if (!MenuSegment.isVersion(currentVersion)) {\r\n      throw new Error('expected version to match a version part');\r\n    }\r\n\r\n    this.addNodeMeta({ currentVersion });\r\n  }\r\n\r\n  private stripVersionNumbersFromLatestVersionInSeoFriendlyPath() {\r\n    const updateSeoPathsRecursively = (\r\n      collection: MenuNode,\r\n      replacePath = null,\r\n      withPath = null,\r\n    ) => {\r\n      for (const [segment, node] of Object.entries(collection)) {\r\n        if (MenuSegment.isMeta(segment)) continue;\r\n\r\n        // Example: Recursively replace /github/v[latest]/something with /github/something.\r\n        if (replacePath && withPath && has(node, 'meta.path')) {\r\n          set(collection, `${segment}.meta.path`, node.meta.path.replace(replacePath, withPath));\r\n        }\r\n\r\n        if (!MenuNode.hasChildren(node)) {\r\n          continue;\r\n        }\r\n\r\n        if (MenuSegment.isVersionContainer(segment)) {\r\n          const { currentVersion } = node.meta;\r\n          const { seoFriendlyPath } = node[currentVersion].meta;\r\n          const replace = get(collection, `${segment}.${currentVersion}.meta.path`);\r\n          set(collection, `${segment}.${currentVersion}.meta.path`, seoFriendlyPath);\r\n          updateSeoPathsRecursively(node, replace, seoFriendlyPath);\r\n          continue;\r\n        }\r\n\r\n        updateSeoPathsRecursively(node, replacePath, withPath);\r\n      }\r\n    };\r\n\r\n    updateSeoPathsRecursively(this.structure);\r\n  }\r\n\r\n  private cleanup() {\r\n    const cleanupRecursively = (collection: MenuNode) => {\r\n      for (const [segment, node] of Object.entries(collection)) {\r\n        if (MenuSegment.isMeta(segment)) continue;\r\n\r\n        unset(collection, `${segment}.meta.seoFriendlyPath`);\r\n\r\n        if (MenuNode.hasChildren(node)) {\r\n          cleanupRecursively(node);\r\n        }\r\n      }\r\n    };\r\n    cleanupRecursively(this.structure);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}